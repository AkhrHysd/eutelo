---
id: ADR-EUTELO-CONFIG-INIT-DIRECTORY-STRUCTURE-0001
type: adr
feature: EUTELO-CONFIG-INIT-DIRECTORY-STRUCTURE
title: Init ディレクトリ構造設定ファイル形式の決定
status: draft
version: 0.1
parent: PRD-EUTELO-CONFIG-INIT-DIRECTORY-STRUCTURE
related: [PRD-EUTELO-CONFIG-INIT-DIRECTORY-STRUCTURE]
deciders: ["@AkhrHysd"]
date: "2025-12-03"
purpose: >
  `eutelo init` コマンドで作成されるディレクトリ構造を設定ファイルで定義する際の
  形式（構造体形式 vs 配列形式）を決定し、ディレクトリとテンプレートの関連性を
  どのように表現するかを明確にする。
---

# ADR-EUTELO-CONFIG-INIT-DIRECTORY-STRUCTURE-0001
Init ディレクトリ構造設定ファイル形式の決定

---

## Context（背景）

`PRD-EUTELO-CONFIG-INIT-DIRECTORY-STRUCTURE` では、`eutelo init` コマンドで作成されるディレクトリ構造を設定ファイルでカスタマイズできる機能を定義している。

現状、ディレクトリ構造は `RELATIVE_STRUCTURE` として固定値でハードコーディングされているが、プロジェクトごとに異なるディレクトリ構造が必要な場合がある。また、ディレクトリとその配下で使用されるドキュメントテンプレートの関連性を明確に定義したいという要望がある。

設定ファイルの形式として、以下の2つの選択肢が検討されている：

1. **構造体形式**: ディレクトリパス、テンプレート情報、説明などをまとめて定義
2. **配列形式**: シンプルなパスの配列のみを定義

どちらの形式を採用するか、または両方をサポートするかを決定する必要がある。

---

## Decision Drivers（意思決定の判断基準）

判断基準は以下の通り：

1. **表現力**: ディレクトリとテンプレートの関連性を明確に表現できるか
2. **拡張性**: 将来的にメタデータ（説明、必須/任意など）を追加しやすいか
3. **後方互換性**: 既存プロジェクトへの影響を最小化できるか
4. **シンプルさ**: 基本的な用途では簡単に記述できるか
5. **検証の容易さ**: 設定ファイルの検証が容易か
6. **既存設定との整合性**: `scaffold` 設定との重複や矛盾を避けられるか

---

## Considered Options（検討した選択肢）

### Option 1: ディレクトリごとのファイル定義形式（採用）

各ディレクトリをキーとし、そのディレクトリに配置されるファイルの種類、テンプレート、ルール、説明などをまとめて定義する。

```json
{
  "docs/product/features/{FEATURE}": [
    {
      "file": "PRD-{FEATURE}.md",
      "template": "templates/prd.md",
      "rules": "rules/prd.json",
      "description": "PRD ドキュメント",
      "prefix": "PRD-",
      "variables": ["FEATURE"],
      "tags": ["prd", "feature"]
    },
    {
      "file": "BEH-{FEATURE}.md",
      "template": "templates/beh.md",
      "rules": "rules/beh.json",
      "description": "BEH ドキュメント",
      "prefix": "BEH-",
      "variables": ["FEATURE"],
      "tags": ["beh", "feature"]
    }
  ],
  "docs/architecture/design/{FEATURE}": [
    {
      "file": "DSG-{FEATURE}.md",
      "template": "templates/dsg.md",
      "rules": "rules/dsg.json",
      "description": "DSG ドキュメント",
      "prefix": "DSG-",
      "variables": ["FEATURE"],
      "tags": ["dsg", "design"]
    }
  ]
}
```

**利点:**
- ディレクトリとファイルの関連性が明確
- テンプレート、ルール、変数などの情報をまとめて定義できる
- `scaffold` 設定との統合が容易（同じ情報源から生成可能）
- 将来的な拡張（メタデータ追加）が容易
- 設定ファイルの可読性が高い
- ディレクトリごとの責務が明確

**欠点:**
- 記述量が多くなる
- 既存の `RELATIVE_STRUCTURE` からの移行がやや複雑

---

### Option 2: 配列形式のみを採用

シンプルなパスの配列のみを定義。

```yaml
directoryStructure:
  - []
  - [requirements]
  - [requirements, features]
  - [design]
  - [decisions]
```

**利点:**
- シンプルで直感的
- 既存の `RELATIVE_STRUCTURE` と同じ形式で移行が容易
- 記述量が少ない

**欠点:**
- ディレクトリとテンプレートの関連性が不明確
- 将来的な拡張が困難
- `scaffold` 設定との整合性チェックが困難

---

### Option 3: 両形式をサポート（推奨）

構造体形式を基本とし、配列形式も後方互換性のためにサポートする。

```yaml
# 構造体形式（推奨）
directoryStructure:
  - path: []
    description: "ドキュメントルート"
  - path: [requirements]
    templates: [prd, beh]

# または配列形式（後方互換性）
directoryStructure:
  - []
  - [requirements]
```

**利点:**
- 構造体形式の表現力と拡張性を活用できる
- 配列形式でシンプルな用途に対応できる
- 既存プロジェクトからの移行が容易
- 段階的な移行が可能

**欠点:**
- 実装がやや複雑になる（形式の判定と正規化が必要）
- 2つの形式をサポートする必要がある

---

## Decision（決定）

**Option 1: ディレクトリごとのファイル定義形式** を採用する。

### 理由

1. **表現力と実用性**: ディレクトリとファイルの関連性、テンプレート、ルール、変数などの情報をまとめて定義でき、実用的
2. **既存設定との統合**: `scaffold` 設定との統合が容易で、同じ情報源から `scaffold` 設定を生成することも可能
3. **将来の拡張性**: ディレクトリごとの詳細な定義により、将来的にメタデータを追加しやすい
4. **可読性**: ディレクトリごとの責務が明確で、設定ファイルの可読性が高い

### 実装方針

1. **ディレクトリごとのファイル定義形式を基本形式とする**
   - 推奨形式としてディレクトリごとのファイル定義形式を採用
   - ディレクトリパスをキーとし、その配下のファイル定義の配列を値とする

2. **配列形式を後方互換形式としてサポート**
   - 配列形式が検出された場合は、内部でディレクトリごとのファイル定義形式に正規化する
   - 既存の `RELATIVE_STRUCTURE` と同じ形式を維持

3. **形式の判定と正規化**
   - 設定ファイル読み込み時に形式を判定
   - 配列形式の場合は、ディレクトリごとのファイル定義形式に正規化
   - ディレクトリごとのファイル定義形式の場合はそのまま使用

4. **`scaffold` 設定との統合**
   - ディレクトリごとのファイル定義から `scaffold` 設定を生成可能
   - 既存の `scaffold` 設定と併用することも可能
   - 両方が定義されている場合は、`scaffold` 設定を優先

---

## Consequences（影響）

### ポジティブな影響

- **表現力**: ディレクトリとファイルの関連性、テンプレート、ルール、変数などの情報をまとめて定義できる
- **統合性**: `scaffold` 設定との統合が容易で、同じ情報源から生成可能
- **拡張性**: 将来的な機能追加に対応しやすい
- **可読性**: ディレクトリごとの責務が明確で、設定ファイルの意図が明確
- **後方互換性**: 配列形式もサポートすることで、既存プロジェクトへの影響を最小化

### ネガティブな影響

- **実装の複雑さ**: 2つの形式をサポートする必要がある
- **検証の複雑さ**: 形式の判定と正規化ロジックが必要
- **記述量**: ディレクトリごとの詳細な定義により、記述量が増える
- **ドキュメントの複雑さ**: 2つの形式を説明する必要がある

### リスクと対策

- **リスク**: 2つの形式が混在し、混乱を招く可能性
  - **対策**: ドキュメントでディレクトリごとのファイル定義形式を推奨し、配列形式は後方互換性のためと明記

- **リスク**: 実装が複雑になり、バグが発生しやすい
  - **対策**: 形式判定と正規化ロジックを明確に分離し、テストを充実させる

- **リスク**: `scaffold` 設定との重複や矛盾が発生する可能性
  - **対策**: ディレクトリごとのファイル定義から `scaffold` 設定を生成する機能を提供し、重複を避ける

---

## Alternatives Considered（検討した他案）

### 構造体形式のみ + マイグレーションツール

構造体形式のみを採用し、配列形式から構造体形式へのマイグレーションツールを提供する案。

**却下理由:**
- 既存プロジェクトへの影響が大きい
- マイグレーションツールの開発・保守コストがかかる
- 段階的な移行ができない

### 配列形式のみ + 別設定でテンプレート情報を定義

配列形式のみを採用し、テンプレート情報は別の設定項目で定義する案。

**却下理由:**
- ディレクトリとテンプレートの関連性が不明確
- 設定ファイルが分散し、管理が困難
- `scaffold` 設定との重複が発生しやすい

---

## Notes（補足）

- 具体的な実装詳細（形式判定ロジック、正規化処理など）は DSG で設計する
- ディレクトリごとのファイル定義形式のスキーマ定義（型定義）も DSG で設計する
- `scaffold` 設定との統合方法（生成、マージなど）も DSG で設計する
- 設定ファイルの例やマイグレーションガイドは実装後に作成する

---

## References

- `PRD-EUTELO-CONFIG-INIT-DIRECTORY-STRUCTURE`: 本機能の要件定義
- `packages/core/src/constants/requiredDirectories.ts`: 既存の固定ディレクトリ構造
- `packages/core/src/config/types.ts`: 既存の設定ファイル型定義

