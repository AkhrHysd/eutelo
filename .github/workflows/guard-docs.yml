name: Guard Docs on Pull Request

on:
  pull_request:
    paths:
      - 'test-docs/**'

jobs:
  guard:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Build packages
        run: npm run build

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            docs/**/*.md

      - name: Validate environment variables
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          if [ -z "${{ secrets.EUTELO_GUARD_API_ENDPOINT }}" ]; then
            echo "Error: EUTELO_GUARD_API_ENDPOINT secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.EUTELO_GUARD_API_KEY }}" ]; then
            echo "Error: EUTELO_GUARD_API_KEY secret is not set"
            exit 1
          fi
          echo "Environment variables validated"

      - name: Run guard check for each changed file
        id: guard-check
        if: steps.changed-files.outputs.any_changed == 'true'
        env:
          EUTELO_GUARD_API_ENDPOINT: ${{ secrets.EUTELO_GUARD_API_ENDPOINT }}
          EUTELO_GUARD_API_KEY: ${{ secrets.EUTELO_GUARD_API_KEY }}
          EUTELO_GUARD_MODEL: ${{ secrets.EUTELO_GUARD_MODEL }}
        run: |
          CHANGED_FILES="${{ steps.changed-files.outputs.all_changed_files }}"
          
          # Create results array
          ALL_RESULTS="[]"
          TOTAL_ISSUES=0
          TOTAL_WARNINGS=0
          HAS_ISSUES=false
          HAS_ERRORS=false
          
          # Process each changed file
          for file in $CHANGED_FILES; do
            if [ ! -f "$file" ]; then
              echo "Skipping deleted file: $file"
              continue
            fi
            
            echo "Checking: $file"
            
            # Run guard for this file (guard will automatically collect related documents)
            # Use --depth=1 to limit traversal depth for CI performance
            # Separate stdout (JSON) and stderr (errors/logs)
            RESULT_FILE="guard-result-$(basename "$file").json"
            ERROR_FILE="guard-error-$(basename "$file").txt"
            
            # Run guard and capture stdout (JSON) and stderr (errors) separately
            npx eutelo guard --format json --depth=1 "$file" > "$RESULT_FILE" 2> "$ERROR_FILE" || GUARD_EXIT=$?
            
            # Debug: Show what was captured
            echo "Guard exit code: ${GUARD_EXIT:-0}"
            if [ -f "$RESULT_FILE" ]; then
              echo "Result file size: $(wc -c < "$RESULT_FILE") bytes"
              if [ -s "$RESULT_FILE" ]; then
                echo "Result file preview (first 200 chars):"
                head -c 200 "$RESULT_FILE" || true
                echo ""
              fi
            else
              echo "Result file does not exist"
            fi
            if [ -f "$ERROR_FILE" ] && [ -s "$ERROR_FILE" ]; then
              echo "Error file content:"
              cat "$ERROR_FILE"
            fi
            
            # Check if result file exists and contains valid JSON
            if [ -f "$RESULT_FILE" ] && [ -s "$RESULT_FILE" ]; then
              # Validate JSON before parsing
              if jq empty "$RESULT_FILE" 2>/dev/null; then
                RESULT=$(cat "$RESULT_FILE")
                
                # Try to parse and merge results
                MERGED=$(echo "$ALL_RESULTS" | jq --argjson result "$RESULT" '. += [$result]' 2>/dev/null)
                
                if [ $? -eq 0 ] && [ -n "$MERGED" ]; then
                  ALL_RESULTS="$MERGED"
                  
                  # Count issues and warnings
                  ISSUES=$(echo "$RESULT" | jq -r '.stats.issues // 0' 2>/dev/null || echo "0")
                  WARNINGS=$(echo "$RESULT" | jq -r '.stats.warnings // 0' 2>/dev/null || echo "0")
                  TOTAL_ISSUES=$((TOTAL_ISSUES + ISSUES))
                  TOTAL_WARNINGS=$((TOTAL_WARNINGS + WARNINGS))
                  
                  # HAS_ISSUES: true if there are any issues or warnings (for PR comment)
                  # HAS_ERRORS: true only if there are issues (for CI failure)
                  if [ "$ISSUES" -gt 0 ] || [ "$WARNINGS" -gt 0 ]; then
                    HAS_ISSUES=true
                  fi
                  if [ "$ISSUES" -gt 0 ]; then
                    HAS_ERRORS=true
                  fi
                else
                  echo "Warning: Failed to merge result for $file"
                  # Read error file if it exists for better error message
                  ERROR_MSG="Failed to parse result"
                  if [ -f "$ERROR_FILE" ] && [ -s "$ERROR_FILE" ]; then
                    ERROR_MSG=$(head -1 "$ERROR_FILE" | tr -d '\n' | head -c 200 | sed 's/"/\\"/g')
                  fi
                  # Create error result entry using a safer method
                  ERROR_RESULT=$(jq -n \
                    --arg file "$file" \
                    --arg error "$ERROR_MSG" \
                    '{origin: {path: $file}, error: {type: "parse", message: $error}, stats: {issues: 0, warnings: 0, suggestions: 0}}')
                  ALL_RESULTS=$(echo "$ALL_RESULTS" | jq --argjson result "$ERROR_RESULT" '. += [$result]' 2>/dev/null || echo "$ALL_RESULTS")
                  HAS_ISSUES=true
                  HAS_ERRORS=true
                fi
              else
                echo "Warning: Result file for $file is not valid JSON"
                # Read error file if it exists
                ERROR_MSG="Invalid JSON output"
                if [ -f "$ERROR_FILE" ] && [ -s "$ERROR_FILE" ]; then
                  # Try to extract JSON from error file (in case error was written to stderr but is valid JSON)
                  ERROR_CONTENT=$(cat "$ERROR_FILE")
                  if echo "$ERROR_CONTENT" | jq empty 2>/dev/null; then
                    # Error file contains valid JSON, use it as result
                    RESULT="$ERROR_CONTENT"
                    MERGED=$(echo "$ALL_RESULTS" | jq --argjson result "$RESULT" '. += [$result]' 2>/dev/null)
                    if [ $? -eq 0 ] && [ -n "$MERGED" ]; then
                      ALL_RESULTS="$MERGED"
                      ISSUES=$(echo "$RESULT" | jq -r '.stats.issues // 0' 2>/dev/null || echo "0")
                      WARNINGS=$(echo "$RESULT" | jq -r '.stats.warnings // 0' 2>/dev/null || echo "0")
                      TOTAL_ISSUES=$((TOTAL_ISSUES + ISSUES))
                      TOTAL_WARNINGS=$((TOTAL_WARNINGS + WARNINGS))
                      if [ "$ISSUES" -gt 0 ] || [ "$WARNINGS" -gt 0 ]; then
                        HAS_ISSUES=true
                      fi
                      if [ "$ISSUES" -gt 0 ]; then
                        HAS_ERRORS=true
                      fi
                      continue
                    fi
                  fi
                  ERROR_MSG=$(head -1 "$ERROR_FILE" | tr -d '\n' | head -c 200 | sed 's/"/\\"/g')
                fi
                # Create error result entry
                ERROR_RESULT=$(jq -n \
                  --arg file "$file" \
                  --arg error "$ERROR_MSG" \
                  '{origin: {path: $file}, error: {type: "execution", message: $error}, stats: {issues: 0, warnings: 0, suggestions: 0}}')
                ALL_RESULTS=$(echo "$ALL_RESULTS" | jq --argjson result "$ERROR_RESULT" '. += [$result]' 2>/dev/null || echo "$ALL_RESULTS")
                HAS_ISSUES=true
              fi
            else
              echo "Warning: No result file generated for $file"
              # Read error file if it exists
              ERROR_MSG="Guard execution failed"
              if [ -f "$ERROR_FILE" ] && [ -s "$ERROR_FILE" ]; then
                # Check if error file contains valid JSON (error might have been written to stderr)
                ERROR_CONTENT=$(cat "$ERROR_FILE")
                echo "Checking if error file contains JSON..."
                if echo "$ERROR_CONTENT" | jq empty 2>/dev/null; then
                  echo "Error file contains valid JSON, using it as result"
                  # Error file contains valid JSON, use it as result
                  RESULT="$ERROR_CONTENT"
                  MERGED=$(echo "$ALL_RESULTS" | jq --argjson result "$RESULT" '. += [$result]' 2>/dev/null)
                  if [ $? -eq 0 ] && [ -n "$MERGED" ]; then
                    ALL_RESULTS="$MERGED"
                    ISSUES=$(echo "$RESULT" | jq -r '.stats.issues // 0' 2>/dev/null || echo "0")
                    WARNINGS=$(echo "$RESULT" | jq -r '.stats.warnings // 0' 2>/dev/null || echo "0")
                    TOTAL_ISSUES=$((TOTAL_ISSUES + ISSUES))
                    TOTAL_WARNINGS=$((TOTAL_WARNINGS + WARNINGS))
                    if [ "$ISSUES" -gt 0 ] || [ "$WARNINGS" -gt 0 ]; then
                      HAS_ISSUES=true
                    fi
                    continue
                  fi
                else
                  echo "Error file does not contain valid JSON"
                  # Try to extract error message from first line
                  ERROR_MSG=$(head -1 "$ERROR_FILE" | tr -d '\n' | head -c 200 | sed 's/"/\\"/g')
                  if [ -z "$ERROR_MSG" ]; then
                    ERROR_MSG="Guard execution failed (no error details available)"
                  fi
                fi
              else
                echo "No error file found or error file is empty"
                # Check if guard command failed
                if [ "${GUARD_EXIT:-0}" -ne 0 ]; then
                  ERROR_MSG="Guard command exited with code ${GUARD_EXIT}"
                else
                  ERROR_MSG="Guard execution failed (no output generated)"
                fi
              fi
              echo "Creating error result with message: $ERROR_MSG"
              # Create error result entry
              ERROR_RESULT=$(jq -n \
                --arg file "$file" \
                --arg error "$ERROR_MSG" \
                '{origin: {path: $file}, error: {type: "execution", message: $error}, stats: {issues: 0, warnings: 0, suggestions: 0}}')
              ALL_RESULTS=$(echo "$ALL_RESULTS" | jq --argjson result "$ERROR_RESULT" '. += [$result]' 2>/dev/null || echo "$ALL_RESULTS")
              HAS_ISSUES=true
            fi
          done
          
          # Output combined results
          echo "guard_result<<EOF" >> $GITHUB_OUTPUT
          echo "$ALL_RESULTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "issues_count=$TOTAL_ISSUES" >> $GITHUB_OUTPUT
          echo "warnings_count=$TOTAL_WARNINGS" >> $GITHUB_OUTPUT
          echo "has_issues=$HAS_ISSUES" >> $GITHUB_OUTPUT
          echo "has_errors=$HAS_ERRORS" >> $GITHUB_OUTPUT
          
          # Don't exit here - we need to post comment first
          # Exit code will be set after comment is posted
          if [ "$HAS_ERRORS" = "true" ]; then
            echo "Errors found: CI will fail after comment is posted"
          elif [ "$HAS_ISSUES" = "true" ]; then
            echo "Warnings found (no errors): CI will pass, but PR comment will be posted"
          else
            echo "No issues or warnings found"
          fi

      - name: Post GitHub comment
        # Post comment if there are issues, warnings, or errors
        # This ensures users can always see the guard check results in PR comments
        if: steps.changed-files.outputs.any_changed == 'true' && (steps.guard-check.outputs.has_issues == 'true' || steps.guard-check.outputs.has_errors == 'true')
        uses: actions/github-script@v7
        with:
          script: |
            const guardResults = JSON.parse(`${{ steps.guard-check.outputs.guard_result }}`);
            const issuesCount = parseInt(`${{ steps.guard-check.outputs.issues_count }}`);
            const warningsCount = parseInt(`${{ steps.guard-check.outputs.warnings_count }}`);
            
            let comment = '## ðŸ“‹ Eutelo Guard Check Results\n\n';
            
            // Aggregate all issues, warnings, and suggestions from all results
            const allIssues = [];
            const allWarnings = [];
            const allSuggestions = [];
            const allErrors = [];
            
            guardResults.forEach((result, index) => {
              if (result.error) {
                allErrors.push({
                  file: result.origin?.path || `File ${index + 1}`,
                  message: result.error.message
                });
              }
              
              if (result.issues) {
                result.issues.forEach(issue => {
                  allIssues.push({
                    ...issue,
                    origin: result.origin?.path || `File ${index + 1}`
                  });
                });
              }
              
              if (result.warnings) {
                result.warnings.forEach(warning => {
                  allWarnings.push({
                    ...warning,
                    origin: result.origin?.path || `File ${index + 1}`
                  });
                });
              }
              
              if (result.suggestions) {
                result.suggestions.forEach(suggestion => {
                  allSuggestions.push({
                    ...suggestion,
                    origin: result.origin?.path || `File ${index + 1}`
                  });
                });
              }
            });
            
            if (allErrors.length > 0) {
              comment += `### âŒ Errors (${allErrors.length})\n\n`;
              allErrors.forEach(err => {
                comment += `- **${err.file}**: ${err.message}\n`;
              });
              comment += '\n';
            }
            
            if (allIssues.length > 0) {
              comment += `### ðŸ”´ Issues (${allIssues.length})\n\n`;
              
              // Limit display to first 20 issues to avoid comment being too long
              const displayIssues = allIssues.slice(0, 20);
              const remainingIssues = allIssues.length - 20;
              
              displayIssues.forEach((issue, index) => {
                const docName = issue.document || issue.origin || 'Unknown';
                const issueId = issue.id || `ISSUE-${index + 1}`;
                comment += `#### ${issueId}\n\n`;
                comment += `**Document**: \`${docName}\`\n\n`;
                comment += `**Message**: ${issue.message}\n\n`;
                if (issue.hint) {
                  comment += `**Hint**: ${issue.hint}\n\n`;
                }
                comment += '---\n\n';
              });
              
              if (remainingIssues > 0) {
                comment += `\n<details>\n<summary>${remainingIssues} more issue(s) (click to expand)</summary>\n\n`;
                allIssues.slice(20).forEach((issue, index) => {
                  const docName = issue.document || issue.origin || 'Unknown';
                  const issueId = issue.id || `ISSUE-${21 + index}`;
                  comment += `#### ${issueId}\n\n`;
                  comment += `**Document**: \`${docName}\`\n\n`;
                  comment += `**Message**: ${issue.message}\n\n`;
                  if (issue.hint) {
                    comment += `**Hint**: ${issue.hint}\n\n`;
                  }
                  comment += '---\n\n';
                });
                comment += '</details>\n\n';
              }
            }
            
            if (allWarnings.length > 0) {
              comment += `### âš ï¸ Warnings (${allWarnings.length})\n\n`;
              
              // Limit display to first 20 warnings to avoid comment being too long
              const displayWarnings = allWarnings.slice(0, 20);
              const remainingWarnings = allWarnings.length - 20;
              
              displayWarnings.forEach((warning, index) => {
                const docName = warning.document || warning.origin || 'Unknown';
                const warningId = warning.id || `WARNING-${index + 1}`;
                comment += `#### ${warningId}\n\n`;
                comment += `**Document**: \`${docName}\`\n\n`;
                comment += `**Message**: ${warning.message}\n\n`;
                if (warning.hint) {
                  comment += `**Hint**: ${warning.hint}\n\n`;
                }
                comment += '---\n\n';
              });
              
              if (remainingWarnings > 0) {
                comment += `\n<details>\n<summary>${remainingWarnings} more warning(s) (click to expand)</summary>\n\n`;
                allWarnings.slice(20).forEach((warning, index) => {
                  const docName = warning.document || warning.origin || 'Unknown';
                  const warningId = warning.id || `WARNING-${21 + index}`;
                  comment += `#### ${warningId}\n\n`;
                  comment += `**Document**: \`${docName}\`\n\n`;
                  comment += `**Message**: ${warning.message}\n\n`;
                  if (warning.hint) {
                    comment += `**Hint**: ${warning.hint}\n\n`;
                  }
                  comment += '---\n\n';
                });
                comment += '</details>\n\n';
              }
            }
            
            if (allSuggestions.length > 0) {
              comment += `### ðŸ’¡ Suggestions (${allSuggestions.length})\n\n`;
              allSuggestions.forEach(suggestion => {
                comment += `- **${suggestion.document || suggestion.origin || 'Unknown'}**: ${suggestion.message}\n`;
              });
              comment += '\n';
            }
            
            comment += `\n**Summary**: Checked ${guardResults.length} file(s). Found ${issuesCount} issue(s) and ${warningsCount} warning(s).\n`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes('Eutelo Guard Check Results')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

      - name: Set exit code if errors found
        # Set exit code after comment is posted
        # This ensures PR comment is always posted before CI fails
        if: steps.guard-check.outputs.has_errors == 'true'
        run: |
          echo "Errors were found. Exiting with code 1."
          exit 1
