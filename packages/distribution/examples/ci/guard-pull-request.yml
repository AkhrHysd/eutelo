name: Guard Docs on Pull Request

on:
  pull_request:
    paths:
      - 'docs/**'

jobs:
  guard:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            docs/**/*.md

      - name: Run guard check for each changed file
        id: guard-check
        if: steps.changed-files.outputs.any_changed == 'true'
        env:
          EUTELO_GUARD_API_ENDPOINT: ${{ secrets.EUTELO_GUARD_API_ENDPOINT }}
          EUTELO_GUARD_API_KEY: ${{ secrets.EUTELO_GUARD_API_KEY }}
          EUTELO_GUARD_MODEL: ${{ secrets.EUTELO_GUARD_MODEL }}
        run: |
          CHANGED_FILES="${{ steps.changed-files.outputs.all_changed_files }}"
          
          # Create results array
          ALL_RESULTS="[]"
          TOTAL_ISSUES=0
          TOTAL_WARNINGS=0
          HAS_ISSUES=false
          
          # Process each changed file
          for file in $CHANGED_FILES; do
            if [ ! -f "$file" ]; then
              echo "Skipping deleted file: $file"
              continue
            fi
            
            echo "Checking: $file"
            
            # Run guard for this file (guard will automatically collect related documents)
            # Use --depth=1 to limit traversal depth for CI performance
            npx eutelo guard --format json --depth=1 "$file" > "guard-result-$(basename "$file").json" 2>&1 || GUARD_EXIT=$?
            
            # Read result
            RESULT_FILE="guard-result-$(basename "$file").json"
            if [ -f "$RESULT_FILE" ]; then
              RESULT=$(cat "$RESULT_FILE")
              
              # Parse JSON and merge results
              ALL_RESULTS=$(echo "$ALL_RESULTS" | jq --argjson result "$RESULT" '. += [$result]')
              
              # Count issues and warnings
              ISSUES=$(echo "$RESULT" | jq -r '.stats.issues // 0')
              WARNINGS=$(echo "$RESULT" | jq -r '.stats.warnings // 0')
              TOTAL_ISSUES=$((TOTAL_ISSUES + ISSUES))
              TOTAL_WARNINGS=$((TOTAL_WARNINGS + WARNINGS))
              
              if [ "$ISSUES" -gt 0 ] || [ "$WARNINGS" -gt 0 ]; then
                HAS_ISSUES=true
              fi
            fi
          done
          
          # Output combined results
          echo "guard_result<<EOF" >> $GITHUB_OUTPUT
          echo "$ALL_RESULTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "issues_count=$TOTAL_ISSUES" >> $GITHUB_OUTPUT
          echo "warnings_count=$TOTAL_WARNINGS" >> $GITHUB_OUTPUT
          echo "has_issues=$HAS_ISSUES" >> $GITHUB_OUTPUT
          
          # Exit with error if any issues found
          if [ "$HAS_ISSUES" = "true" ]; then
            exit 1
          fi

      - name: Post GitHub comment
        if: steps.changed-files.outputs.any_changed == 'true' && steps.guard-check.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const guardResults = JSON.parse(`${{ steps.guard-check.outputs.guard_result }}`);
            const issuesCount = parseInt(`${{ steps.guard-check.outputs.issues_count }}`);
            const warningsCount = parseInt(`${{ steps.guard-check.outputs.warnings_count }}`);
            
            let comment = '## ðŸ“‹ Eutelo Guard Check Results\n\n';
            
            // Aggregate all issues, warnings, and suggestions from all results
            const allIssues = [];
            const allWarnings = [];
            const allSuggestions = [];
            const allErrors = [];
            
            guardResults.forEach((result, index) => {
              if (result.error) {
                allErrors.push({
                  file: result.origin?.path || `File ${index + 1}`,
                  message: result.error.message
                });
              }
              
              if (result.issues) {
                result.issues.forEach(issue => {
                  allIssues.push({
                    ...issue,
                    origin: result.origin?.path || `File ${index + 1}`
                  });
                });
              }
              
              if (result.warnings) {
                result.warnings.forEach(warning => {
                  allWarnings.push({
                    ...warning,
                    origin: result.origin?.path || `File ${index + 1}`
                  });
                });
              }
              
              if (result.suggestions) {
                result.suggestions.forEach(suggestion => {
                  allSuggestions.push({
                    ...suggestion,
                    origin: result.origin?.path || `File ${index + 1}`
                  });
                });
              }
            });
            
            if (allErrors.length > 0) {
              comment += `### âŒ Errors (${allErrors.length})\n\n`;
              allErrors.forEach(err => {
                comment += `- **${err.file}**: ${err.message}\n`;
              });
              comment += '\n';
            }
            
            if (allIssues.length > 0) {
              comment += `### ðŸ”´ Issues (${allIssues.length})\n\n`;
              allIssues.forEach(issue => {
                comment += `- **${issue.document || issue.origin || 'Unknown'}**: ${issue.message}\n`;
                if (issue.context) {
                  comment += `  \`\`\`\n  ${issue.context}\n  \`\`\`\n`;
                }
              });
              comment += '\n';
            }
            
            if (allWarnings.length > 0) {
              comment += `### âš ï¸ Warnings (${allWarnings.length})\n\n`;
              allWarnings.forEach(warning => {
                comment += `- **${warning.document || warning.origin || 'Unknown'}**: ${warning.message}\n`;
                if (warning.context) {
                  comment += `  \`\`\`\n  ${warning.context}\n  \`\`\`\n`;
                }
              });
              comment += '\n';
            }
            
            if (allSuggestions.length > 0) {
              comment += `### ðŸ’¡ Suggestions (${allSuggestions.length})\n\n`;
              allSuggestions.forEach(suggestion => {
                comment += `- **${suggestion.document || suggestion.origin || 'Unknown'}**: ${suggestion.message}\n`;
              });
              comment += '\n';
            }
            
            comment += `\n**Summary**: Checked ${guardResults.length} file(s). Found ${issuesCount} issue(s) and ${warningsCount} warning(s).\n`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes('Eutelo Guard Check Results')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
